InfoSL2toBBG := NewInfoClass("InfoSL2toBBG");
SetInfoLevel(InfoSL2toBBG,1);


IsInCenter:=function(S,g)
# "S" is generating set for a group, "g" is an element in the group.
# This function returns
# true: if "g" commutes with the group generated by the list "S".
# false: otherwise

local n,a,found;

found:=false;
a:=1;
n:=Length(S);
  while not found and a<=n do
    if g*S[a] = S[a]*g then
      a:=a+1;
      found:=false;
    else
      return false;
    fi;
  od;
    if not found then
      return true;
    fi;
end;
###################################################################
###################################################################
Invo:=function(S,Eo)
# "S" is a generating set for a group;
# "Eo" is the odd part of an exponent of the group.
# This function returns an involution produced from a random element in the group.

local G,found,g,finished;

G:=Group(S);
found:=false;
  while not found do
    g:=PseudoRandom(G);
    g:=g^Eo;
      if IsInCenter(S,g) then
        found:=false;
      else
        finished:=false;
          while not finished do
            if IsInCenter(S,g^2) then
              return g;
            else
              g:=g^2;
            fi;
          od;
      fi;
  od;
end;
###################################################################
###################################################################
CentralizerInvo:=function(S,i,Eo)
  # "S" is a generating set for a group;
  # "i" is an involution in the group;
  # "Eo" is the odd part of an exponent of the group.
  # This function returns a generating set for the centralizer of "i" in the group by using only the map "zeta_1".

  local G,l,found,a,x,y,o;

  G:=Group(S);
  l:=[];
    for a in [1..40] do
      found:=false;
        while not found do
          x:=PseudoRandom(G);
          y:=i*i^x;
            if IsInCenter(S,y^Eo) then
              if IsInCenter(S,y) then
                l[a]:=i^x;
                found:=true;
              else
                l[a]:=(y^((Eo+1)/2))*x^(-1);
                found:=true;
              fi;
            else
              found:=false;
            fi;
        od;
    od;
  return l;
  end;
###################################################################
###################################################################
TorusRandom:=function(S,C)
# "S" is a generating set for a group isomorphic to SL2;
# "C" is a generating set for a centralizer of an involution.
# This function returns a random element from the torus in "C". In this function, we avoid the possibility to construct the involution in the torus.

local found,CC,g;

CC:=Group(C);
found:=false;
  while not found do
    g:=PseudoRandom(C);
      if (not IsInCenter(S,g)) and (not IsInCenter(S,g^2)) and (not IsInCenter(S,g^4)) then
        return g;
      fi;
  od;
end;
###################################################################
###################################################################
CentralizerProtoInvo:=function(S,C,t,Eo)
    # "S" is a generating set for a group isomorphic to (P)SL2;
    # "C" is a generating set for a centralizer of an involution;
    # "t" is a semisimple group element of odd order;
    # "Eo" is the odd part of an exponent of the group.
    # This function returns a generating set for the centralizer of an involution which inverts the torus in "C" and centralizes "t".

    local l,found,a,x1,x2,x3,y1,y2,y3,zz,zzalpha;

    l:=[];
      for a in [1..40] do
        found:=false;
          while not found do
            x1:=TorusRandom(S,C);
            x2:=TorusRandom(S,C);
            x3:=TorusRandom(S,C);
            y1:=PseudoRandom(Group(t));
            y2:=PseudoRandom(Group(t));
            y3:=PseudoRandom(Group(t));
            zz:=x1*y1*x2*y2*x3*y3;
            zzalpha:=(x1^-1)*y1*(x2^-1)*y2*(x3^-1)*y3;
              if IsInCenter(S,(zzalpha*(zz^-1))^Eo) then
                if IsInCenter(S,zzalpha*(zz^-1)) then
                  l[a]:=zz;
                  found:=true;
                else
                  l[a]:=((zzalpha*(zz^-1))^((Eo+1)/2))*zz;
                  found:=true;
                fi;
              else
                found:=false;
              fi;
          od;
      od;
    return l;
    end;
###################################################################
###################################################################
IsUnipotent:=function(S,i,j,Eo)
# "S" is a generating set for a group isomorphic to PGL2 or (P)SL2;
# "i" and "j" are involutions;
# "Eo" is the odd part of an exponent of the group.
# This function returns the truth value whether the product "i*j" is a unipotent element or not.

local u,Ci,found,ti;

u:=i*j;
Ci:=Group(CentralizerInvo(S,i,Eo));
found:=false;
  while not found do
    ti:=PseudoRandom(Ci);
      if (not IsInCenter(S,ti)) and (not IsInCenter(S,ti^2)) and (not IsInCenter(S,ti^3)) then
        found:=true;
      fi;
  od;
  if (not IsInCenter(S,u*((u^ti)^-1))) and IsInCenter(S,(u*(u^ti)*(u^-1))*((u^ti)^-1)) and (not IsInCenter(S,u)) and (not IsInCenter(S,u^2)) then
    return true;
  else
    return false;
  fi;
end;
###################################################################
###################################################################
BinaryRep:=function(n)
# "n" is a natural number.
# This function returns a list consisting of natural numbers c1,...,ck such that 2^{c1+...+ck}=n.

local l,stop,finished,a,b,c,d;

l:=[];
stop:=false;
finished:=false;
a:=0;
  while not stop do
    if 2^a=n then
      stop:=true;
      finished:=true;
    elif  2^a > n then
      stop:=true;
      a:=a-1;
    else
      a:=a+1;
    fi;
  od;
l[1]:=a;
n:=n-2^a;
c:=2;
  while not finished do
    stop:=false;
    b:=1;
      while not stop do
        d:=2^(a-b);
          if d = n then
            stop:=true;
            finished:=true;
            l[c]:=a-b;
          elif d > n then
            stop:=false;
            b:=b+1;
          else
            stop:=true;
            l[c]:=a-b;
            a:=a-b;
            c:=c+1;
            n:=n-d;
          fi;
      od;
  od;
return l;
end;
###################################################################
###################################################################
SetUpForPGL2:=function(S,Eo)
    # "S" is a generating set for the group (P)SL2.
    # The function returns "S" together with a generating set "cu" which is a centralizer of an involution inverted by the diagonal automorphism,
    # and an element "z" centralized by the diagonal automorphism. With these generating sets and the action of the diagonal automorphism on
    # these sets, we can generate PGL2 by using the arguments in the paper "Adjoint representations of the black box groups PSL2".

    local G,i,Ci,found,y,z,finished,cproto,check,a,t;

    G:=Group(S);
    i:=Invo(S,Eo);
    Ci:=CentralizerInvo(S,i,Eo);
    finished:=false;
      while not finished do
        found:=false;
          while not found do
            y:=PseudoRandom(G);
            z:=i*(i^y);
              if IsUnipotent(S,i,i^y,Eo) then
                found:=false;
              elif (not IsInCenter(S,z)) and (IsInCenter(S,z^Eo)) then
                found:=true;
              fi;
          od;
        cproto:=CentralizerProtoInvo(S,Ci,z,Eo);
        check:=false;
        a:=1;
        t:=[];
          while (not check) and a<=20 do
            t[a]:=TorusRandom(S,cproto);
              if not IsInCenter(S,t[a]^Eo) then
                check:=true;
              else
                a:=a+1;
              fi;
          od;
          if check then
            finished:=false;
          elif a=21 then
            finished:=true;
          fi;
      od;
    return [S,Ci,Concatenation(t,[z]),i];
    end;
###################################################################
###################################################################
PseudoRandomPGL2:=function(Snew)
# "Snew" is the output of "SetUpForPGL2".
# This function returns a pseudorandom element from our semidirect product isomorphic to PGL2.

local T,S,sl,tl,a,n,o1,o2,o3;

T:=Group(Snew[2]);
S:=Group(Snew[3]);
sl:=[];
tl:=[];
n:=Random([3..5]);
  for a in [1..n] do
    sl[a]:=PseudoRandom(S);
  od;
  for a in [1..n] do
    tl[a]:=TorusRandom(Snew[1],Snew[2]);
  od;
  o1:=tl[1]*sl[1];
  for a in [2..n] do
    o1:=o1*tl[a]*sl[a];
  od;
  o2:=(tl[1]^-1)*sl[1];
  for a in [2..n] do
    o2:=o2*(tl[a]^-1)*sl[a];
  od;
  o3:=Random(0,1);
return [o1,o2,o3];
end;
###################################################################
###################################################################
PseudoRandomPSL2:=function(Snew)
# "Snew" is the output of "SetUpForPGL2".
# This function returns a pseudorandom element from our semidirect product isomorphic to PSL2.

local T,S,sl,tl,a,n,o1,o2,o3;

T:=Group(Snew[2]);
S:=Group(Snew[3]);
sl:=[];
tl:=[];
n:=Random([3..5]);
  for a in [1..n] do
    sl[a]:=PseudoRandom(S);
  od;
  for a in [1..n] do
    tl[a]:=TorusRandom(Snew[1],Snew[2]);
  od;
  o1:=tl[1]*sl[1];
  for a in [2..n] do
    o1:=o1*tl[a]*sl[a];
  od;
  o2:=(tl[1]^-1)*sl[1];
  for a in [2..n] do
    o2:=o2*(tl[a]^-1)*sl[a];
  od;
return [o1,o2,0];
end;
###################################################################
###################################################################
GeneratorsPGL2:=function(Snew)
# "Snew" is the output of "SetUpForPGL2".
# This function returns a generating set for our semidirect product isomorphic to PGL2.

local a,ll;

ll:=[];
for a in [1..40] do
  ll[a]:=PseudoRandomPGL2(Snew);
od;
return ll;
end;
###################################################################
###################################################################
IsIdentitySD:=function(Snew,A)
# "Snew" is the output of "SetUpForPGL2";
# "A" is an element from our semidirect product isomorphic to PGL2.
# This function returns a truth value whether the element "A" is the identity element in our semidirect product.

  if A[3]=1 then
    return false;
  else
    if IsInCenter(Snew[1],A[1]) and IsInCenter(Snew[1],A[2]) then
      return true;
    else
      return false;
    fi;
  fi;
end;
###################################################################
###################################################################
ProductSD:=function(A,B)
# "A", "B" are elements from our semidirect product isomorphic to PGL2.
# This function returns the product of A and B in the group.

  if A[3]=0 then
    return [A[1]*B[1], A[2]*B[2], B[3]];
  else
    return [A[1]*B[2], A[2]*B[1], ((A[3]+B[3]) mod 2)];
  fi;
end;
###################################################################
###################################################################
PseudoRandomSD:=function(Ss)
# "Ss" is a generating set for a subgroup in our semidirect product isomorphic to PGL2.
# This function returns a pseudorandom element from the group generated by "Ss".

local a,g,b;

a:=Random([3..5]);
g:=PseudoRandom(Ss);
  for b in [1..a] do
    g:=ProductSD(g,PseudoRandom(Ss));
  od;
return g;
end;
###################################################################
###################################################################
PseudoRandomCyclicSD:=function(g)
# "g" is an element from our semidirect product isomorphic to PGL2.
# This function returns a pseudorandom element from the cyclic group < g >.

local l,a,h;

l:=[];
l[1]:=g;
for a in [2..40] do
  h:=PseudoRandom(l);
  h:=ProductSD(h,g);
  l[a]:=h;
od;
return h;
end;
###################################################################
###################################################################
PowerSD:=function(A,n)
# "A" is an element from our semidirect product isomorphic to PGL2;
# "n" is a natural number.
# This function returns the nth power of A in the group.

if A[3] = 0 then
  return [A[1]^n, A[2]^n,0];
else
  if n mod 2 = 0 then
    return [(A[1]*A[2])^(n/2),(A[2]*A[1])^(n/2),0];
  else
    return [((A[1]*A[2])^((n-1)/2))*A[1],((A[2]*A[1])^((n-1)/2))*A[2],1];
  fi;
fi;
end;
###################################################################
###################################################################
InverseSD:=function(A)
# "A" is an element from our semidirect product isomorphic to PGL2.
# This function returns the inverse of A in the group.

  if A[3]=0 then
    return [A[1]^-1,A[2]^-1,A[3]];
  else
    return [A[2]^-1,A[1]^-1,A[3]];
  fi;
end;
###################################################################
###################################################################
ConjugationSD:=function(A,B)
# "A" and "B" are elements from our semidirect product isomorphic to PGL2.
# This function returns A^B.

return ProductSD(ProductSD(InverseSD(B),A),B);
end;
###################################################################
###################################################################
EquivalentInSD:=function(Snew,g,h)
# "Snew" is the output of "SetUpForPGL2";
# "g" and "h" are elements from our semidirect product isomorphic to PGL2.
# This function returns the truth value whether the elements "g" and "h" are representing the same element in our semidirect product.

  if IsIdentitySD(Snew,ProductSD(g,InverseSD(h))) then
    return true;
  else
    return false;
  fi;
end;
###################################################################
###################################################################
2HeightSD:=function(Snew,g,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "g" is an element from our semidirect product isomorphic to PGL2.
# "Eo" is the odd part of an exponent of the group.
# This function returns the 2-height of the group element "g".

local finished,count,gg,ggg;

finished:=false;
count:=0;
gg:=PowerSD(g,Eo);
ggg:=gg;
  while not finished do
    if IsIdentitySD(Snew,gg) then
      finished:=true;
    else
      gg:=ProductSD(gg,gg);
      count:=count+1;
    fi;
  od;
return [count,ggg];
end;
###################################################################
###################################################################
4DividesOrderSD:=function(Snew,g,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "g" is an element from our semidirect product isomorphic to PGL2;
# "Eo" is the odd part of an exponent of the group.
# This function returns the truth value whether the order of "g" is divisible by 4.

g:=PowerSD(g,Eo);
  if IsIdentitySD(Snew,g) or IsIdentitySD(Snew,ProductSD(g,g)) then
    return false;
  else
    return true;
  fi;
end;
###################################################################
###################################################################
ElementOrder4SD:=function(Snew,g,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "g" is an element from our semidirect product isomorphic to PGL2;
# "Eo" is the odd part of an exponent of the group.
# This function is used precisely when the order of "g" is divisible by 4 and it returns an element of order 4 in the cyclic group generated by "g".

local finished;

g:=PowerSD(g,Eo);
finished:=false;
  while not finished do
    if (not IsIdentitySD(Snew,g)) and (not IsIdentitySD(Snew,PowerSD(g,2))) and (IsIdentitySD(Snew,PowerSD(g,4))) then
      return g;
    else
      g:=PowerSD(g,2);
    fi;
  od;
end;
###################################################################
###################################################################
InvoSD:=function(Snew,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "Eo" is the odd part of an exponent of the group.
# This function returns an involution from our semidirect product isomorphic to PGL2.

local found,g,finished;

found:=false;
  while not found do
    g:=PseudoRandomPGL2(Snew);
    g:=PowerSD(g,Eo);
      if IsIdentitySD(Snew,g) then
        found:=false;
      else
        finished:=false;
          while not finished do
            if IsIdentitySD(Snew,ProductSD(g,g)) then
              return g;
            else
              g:=ProductSD(g,g);
            fi;
          od;
      fi;
  od;
end;
###################################################################
###################################################################
InvoSubSD:=function(Snew,Ss,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "Ss" is a generating set for a subgroup in our semidirect product isomorphic to PGL2.
# "Eo" is the odd part of an exponent of the group.
# This function returns an involution produced from a random element in the group generated by "Ss".

local found,g,finished;

found:=false;
  while not found do
    g:=PseudoRandomSD(Ss);
    g:=PowerSD(g,Eo);
      if IsIdentitySD(Snew,g) then
        found:=false;
      else
        finished:=false;
          while not finished do
            if IsIdentitySD(Snew,ProductSD(g,g)) then
              return g;
            else
              g:=ProductSD(g,g);
            fi;
          od;
      fi;
  od;
end;
###################################################################
###################################################################
InvoEvenSD:=function(Snew,g)
# "Snew" is the output of "SetUpForPGL2";
# "g" is an element from our semidirect product isomorphic to PGL2.
# This function returns an involution produced from the element "g" of even order. It is known that "g" has even order for this function.

local finished;

finished:=false;
  while not finished do
    if IsIdentitySD(Snew,PowerSD(g,2)) then
      return g;
    else
      g:=PowerSD(g,2);
    fi;
  od;
end;
###################################################################
###################################################################
InvoEvenHeightSD:=function(Snew,g)
# "Snew" is the output of "SetUpForPGL2";
# "g" is an element from our semidirect product isomorphic to PGL2.
# This function returns an involution produced from the element "g" of even order. It is known that "g" has even order for this function.

local finished,a;

a:=1;
finished:=false;
  while not finished do
    if IsIdentitySD(Snew,PowerSD(g,2)) then
      return [g,a];
    else
      g:=PowerSD(g,2);
      a:=a+1;
    fi;
  od;
end;
###################################################################
###################################################################
CentralizerInvoSD:=function(Snew,i,Eo)
    # "Snew" is the output of "SetUpForPGL2";
    # "i" is an involution from our semidirect product isomorphic to PGL2;
    # "Eo" is the odd part of an exponent of the group.
    # This function returns a generating set for the centralizer of "i" in the group by using only the map "zeta_1".

    local l,found,a,x,y,z,o;

    l:=[];
      for a in [1..40] do
        found:=false;
          while not found do
            x:=PseudoRandomPGL2(Snew);
            z:=ConjugationSD(i,x);
            y:=ProductSD(i,z);
              if IsIdentitySD(Snew,PowerSD(y,Eo)) then
                if IsIdentitySD(Snew,y) then
                  l[a]:=z;
                  found:=true;
                else
                  l[a]:=ProductSD(PowerSD(y,((Eo+1)/2)),InverseSD(x));
                  found:=true;
                fi;
              else
                found:=false;
              fi;
          od;
      od;
    return l;
    end;
###################################################################
###################################################################
CentralizerInvoInSubgroupSD:=function(Snew,Ss,i,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "Ss" is a generating set for a subgroup in our semidirect product isomorphic to PGL2;
# "i" is an involution from our semidirect product isomorphic to PGL2 belonging to subgroup generated by "Ss";
# "Eo" is the odd part of an exponent of the group.
# This function returns a generating set for the centralizer of "i" in the subgroup generated by < Ss > by using only the map "zeta_1".

local l,found,a,x,y,z,o;

l:=[];
  for a in [1..40] do
    found:=false;
      while not found do
        x:=PseudoRandomSD(Ss);
        z:=ConjugationSD(i,x);
        y:=ProductSD(i,z);
          if IsIdentitySD(Snew,PowerSD(y,Eo)) then
            if IsIdentitySD(Snew,y) then
              l[a]:=z;
              found:=true;
            else
              l[a]:=ProductSD(PowerSD(y,((Eo+1)/2)),InverseSD(x));
              found:=true;
            fi;
          else
            found:=false;
          fi;
      od;
  od;
return l;
end;
###################################################################
###################################################################
TorusRandomSD:=function(Snew,C)
# "Snew" is the output of "SetUpForPGL2";
# "C" is a generating set for a centralizer of an involution.
# This function returns a random element from the torus in the group generated by "C".

local found,g;

found:=false;
  while not found do
    g:=PseudoRandomSD(C);
      if (not IsIdentitySD(Snew,g)) and (not IsIdentitySD(Snew,ProductSD(g,g))) then
        return g;
      fi;
  od;
end;
###################################################################
###################################################################
SquareRootTorusSD:=function(Snew,C,g,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "C" is a generating set for a centralizer of an involution;
# "g" is an element from our semidirect product isomorphic to PGL2.
# "Eo" is the odd part of an exponent of the group.
# This function either returns a square root of the group element "g", if exists, inside the torus it lies in, or fails otherwise.

local Y,finished,count,tr,YY,A,R,M,t,a,b,c;

Info(InfoSL2toBBG,1, "Computing a square root in a torus.");
Y:=2HeightSD(Snew,g,Eo);
finished:=false;
count:=1;
  while (not finished) and (count<=19) do
    tr:=TorusRandomSD(Snew,C);
    YY:=2HeightSD(Snew,tr,Eo);
      if YY[1]>Y[1] then
        finished:=true;
      else
        count:=count+1;
      fi;
  od;
  if count=20 then
    Info(InfoSL2toBBG,1,"Square root does not exist for this element.");
    return false;
  fi;
A:=(Eo+1)/2;
R:=PowerSD(g,A);
M:=YY[1];
t:=Y[2];
c:=YY[2];
finished:=false;
  while (not finished) do
    if IsIdentitySD(Snew,t) then
      return R;
    else
      a:=2HeightSD(Snew,t,Eo)[1];
          if ((M-a-1)=0) then
            b:=c;
          else
            b:=PowerSD(c,(2^(M-a-1)));
          fi;
        M:=a;
        c:=ProductSD(b,b);
        t:=ProductSD(t,c);
        R:=ProductSD(R,b);
      fi;
  od;
end;
###################################################################
###################################################################
ConjugatingInvoSD:=function(Snew,Ss,i,j,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "Ss" is a generating set for a subgroup in our semidirect product PGL2;
# "i" and "j" are involutions;
# "Eo" is the odd part of an exponent of the group.
# This function returns a conjugating involution "k" satisfying "i^k=j". The involution "k" belongs to the subgroup generated by the list "Ss"

local z,zz,c,t;

z:=ProductSD(i,j);
zz:=PowerSD(z,Eo);
  if IsIdentitySD(Snew,zz) then
    return ProductSD(PowerSD(z,((Eo+1)/2)),j);
  else
    zz:=InvoEvenSD(Snew,zz);
    c:=CentralizerInvoSD(Snew,zz,Eo);
    t:=SquareRootTorusSD(Snew,c,z,Eo);
    return ProductSD(t,j);
  fi;
end;
###################################################################
###################################################################
DecompositionIntoInvosSD:=function(Snew,a,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "a" is an element from our semidirect product isomorphic to PGL2.
# "Eo" is the odd part of an exponent of the group.
# This function returns a list consisting of two involutions whose product is the group element "a".

local finished,b,k,r1,r2,r3,t1,t2,t3,g,gh1,gh2,h,h2,z,list,found,count,gg,ggi;

finished:=false;
list:=[];
  while not finished do
    b:=PseudoRandomPGL2(Snew);
    if (not IsIdentitySD(Snew,PowerSD(b,2))) then
      for k in [1..40] do
        r1:=PseudoRandomCyclicSD(a);
        r2:=PseudoRandomCyclicSD(a);
        r3:=PseudoRandomCyclicSD(a);
        t1:=PseudoRandomCyclicSD(b);
        t2:=PseudoRandomCyclicSD(b);
        t3:=PseudoRandomCyclicSD(b);
        g:=ProductSD(r1,ProductSD(t1,ProductSD(r2,ProductSD(t2,ProductSD(r3,t3)))));
        gh1:=ProductSD(InverseSD(r1),ProductSD(InverseSD(t1),ProductSD(InverseSD(r2),ProductSD(InverseSD(t2),ProductSD(InverseSD(r3),InverseSD(t3))))));
        gh2:=ProductSD(InverseSD(t3),ProductSD(InverseSD(r3),ProductSD(InverseSD(t2),ProductSD(InverseSD(r2),ProductSD(InverseSD(t1),InverseSD(r1))))));
        h:=ProductSD(gh1,gh2);
        h2:=PowerSD(h,Eo);
            if IsIdentitySD(Snew,h2) then
              z:=ProductSD(PowerSD(h,((Eo+1)/2)),g);
            else
              z:=InvoEvenSD(Snew,h2);
            fi;
          list[k]:=z;
      od;
    found:=false;
    count:=1;
      while (not found) and (count<=20)  do
        g:=TorusRandomSD(Snew,list);
        gg:=PowerSD(g,Eo);
          if (not IsIdentitySD(Snew,gg)) then
            ggi:=InvoEvenSD(Snew,gg);
              if EquivalentInSD(Snew,ConjugationSD(a,ggi),InverseSD(a)) and EquivalentInSD(Snew,ConjugationSD(b,ggi),InverseSD(b)) then
                return [ggi,ProductSD(ggi,a)];
              fi;
          else
            count:=count+1;
          fi;
      od;
    fi;
  od;
end;
###################################################################
###################################################################
IsUnipotentSD:=function(Snew,i,j,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "i" and "j" are involutions;
# "Eo" is the odd part of an exponent of the group.
# This function returns the truth value whether the product "i*j" is a unipotent element or not.

local u,ci,found,ti,check;

u:=ProductSD(i,j);
ci:=CentralizerInvoSD(Snew,i,Eo);
found:=false;
  while not found do
    ti:=PseudoRandomSD(ci);
      if (not IsIdentitySD(Snew,ti)) and (not IsIdentitySD(Snew,PowerSD(ti,2))) and (not IsIdentitySD(Snew,PowerSD(ti,3))) then
        found:=true;
      fi;
  od;
  check:=IsIdentitySD(Snew,ProductSD(u,ProductSD(ConjugationSD(u,ti),ProductSD(InverseSD(u),InverseSD(ConjugationSD(u,ti))))));
  if (not EquivalentInSD(Snew,u,ConjugationSD(u,ti))) and check and (not IsIdentitySD(Snew,u)) and (not IsIdentitySD(Snew,PowerSD(u,2))) then
    return true;
  else
    return false;
  fi;
end;
###################################################################
###################################################################
ReificationSD:=function(Snew,i,j,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "i" and "j" are involutions corresponding to some projective points;
# "Eo" is the odd part of an exponent of the group.
# This function returns either an involution (as a projective point) "k" where the projective points i,j lies on a projective line determined by the involution "k",
# or a unipotent element (as a projective point) "u" where i,j lies on this parabolic line determined by "u".

local regreg,regpar,parreg,parpar,list,r,rr,vi,a,r1,r2,r3,t1,t2,t3,g2,gh1,gh2,h2,hh2,t,z,found,g,gg,found2,found3,found4;

############
# We first determine the nature of the points: regular or parabolic
############
regreg:=false;
regpar:=false;
parreg:=false;
parpar:=false;
  if i[1]=false and j[1]=false then
    regreg:=true;
  elif i[1]=false and j[1]=true then
    regpar:=true;
  elif i[1]=true and j[1]=false then
    parreg:=true;
  elif i[1]=true and j[1]=true then
    parpar:=true;
  fi;

list:=[];
  if regreg then
    if IsUnipotentSD(Snew,i[2],j[2],Eo) then
      return [true,i[2],j[2],ProductSD(i[2],j[2])];
    else
      r:=ProductSD(i[2],j[2]);
      rr:=PowerSD(r,Eo);
        if (not IsIdentitySD(Snew,rr)) then
          return [false, InvoEvenSD(Snew,rr)];
        else
          vi:=CentralizerInvoSD(Snew,i[2],Eo);
            for a in [1..40] do
              r1:=PseudoRandomCyclicSD(r);
              r2:=PseudoRandomCyclicSD(r);
              r3:=PseudoRandomCyclicSD(r);
              t1:=TorusRandomSD(Snew,vi);
              t2:=TorusRandomSD(Snew,vi);
              t3:=TorusRandomSD(Snew,vi);
              g2:=ProductSD(r1,ProductSD(t1,ProductSD(r2,ProductSD(t2,ProductSD(r3,t3)))));
              gh1:=ProductSD(r1,ProductSD(InverseSD(t1),ProductSD(r2,ProductSD(InverseSD(t2),ProductSD(r3, InverseSD(t3))))));
              gh2:=ProductSD(InverseSD(t3),ProductSD(InverseSD(r3),ProductSD(InverseSD(t2),ProductSD(InverseSD(r2),ProductSD(InverseSD(t1),InverseSD(r1))))));
              h2:=ProductSD(gh1,gh2);
              hh2:=PowerSD(h2,Eo);
                if IsIdentitySD(Snew,hh2) then
                  z:=ProductSD(PowerSD(h2,((Eo+1)/2)),g2);
                else
                  z:=InvoEvenSD(Snew,hh2);
                fi;
              list[a]:=z;
            od;
        fi;
    fi;

  elif regpar then
    if EquivalentInSD(Snew,ConjugationSD(j[4],i[2]),InverseSD(j[4])) then
      return [true,i[2], ProductSD(i[2],j[4]), j[4]];
    else
      vi:=CentralizerInvoSD(Snew,i[2],Eo);
      r:=j[4];
        for a in [1..40] do
          r1:=PseudoRandomCyclicSD(r);
          r2:=PseudoRandomCyclicSD(r);
          r3:=PseudoRandomCyclicSD(r);
          t1:=TorusRandomSD(Snew,vi);
          t2:=TorusRandomSD(Snew,vi);
          t3:=TorusRandomSD(Snew,vi);
          g2:=ProductSD(t1,ProductSD(r1,ProductSD(t2,ProductSD(r2,ProductSD(t3,r3)))));
          gh1:=ProductSD(InverseSD(t1),ProductSD(InverseSD(r1),ProductSD(InverseSD(t2),ProductSD(InverseSD(r2),ProductSD(InverseSD(t3),InverseSD(r3))))));
          gh2:=ProductSD(InverseSD(r3),ProductSD(InverseSD(t3),ProductSD(InverseSD(r2),ProductSD(InverseSD(t2),ProductSD(InverseSD(r1),InverseSD(t1))))));
          h2:=ProductSD(gh1,gh2);
          hh2:=PowerSD(h2,Eo);
            if IsIdentitySD(Snew,hh2) then
              z:=ProductSD(PowerSD(h2,((Eo+1)/2)),g2);
            else
              z:=InvoEvenSD(Snew,hh2);
            fi;
          list[a]:=z;
        od;
    fi;

  elif parreg then
    if EquivalentInSD(Snew,ConjugationSD(i[4],j[2]),InverseSD(i[4])) then
      return [true,j[2], ProductSD(j[2],i[4]), i[4]];
    else
      vi:=CentralizerInvoSD(Snew,j[2],Eo);
      r:=i[4];
        for a in [1..40] do
          r1:=PseudoRandomCyclicSD(r);
          r2:=PseudoRandomCyclicSD(r);
          r3:=PseudoRandomCyclicSD(r);
          t1:=TorusRandomSD(Snew,vi);
          t2:=TorusRandomSD(Snew,vi);
          t3:=TorusRandomSD(Snew,vi);
          g2:=ProductSD(t1,ProductSD(r1,ProductSD(t2,ProductSD(r2,ProductSD(t3,r3)))));
          gh1:=ProductSD(InverseSD(t1),ProductSD(InverseSD(r1),ProductSD(InverseSD(t2),ProductSD(InverseSD(r2),ProductSD(InverseSD(t3),InverseSD(r3))))));
          gh2:=ProductSD(InverseSD(r3),ProductSD(InverseSD(t3),ProductSD(InverseSD(r2),ProductSD(InverseSD(t2),ProductSD(InverseSD(r1),InverseSD(t1))))));
          h2:=ProductSD(gh1,gh2);
          hh2:=PowerSD(h2,Eo);
            if IsIdentitySD(Snew,hh2) then
              z:=ProductSD(PowerSD(h2,((Eo+1)/2)),g2);
            else
              z:=InvoEvenSD(Snew,hh2);
            fi;
          list[a]:=z;
        od;
    fi;

  elif parpar then
    r:=i[4];
    t:=j[4];
      for a in [1..40] do
        r1:=PseudoRandomCyclicSD(r);
        r2:=PseudoRandomCyclicSD(r);
        r3:=PseudoRandomCyclicSD(r);
        t1:=PseudoRandomCyclicSD(t);
        t2:=PseudoRandomCyclicSD(t);
        t3:=PseudoRandomCyclicSD(t);
        g2:=ProductSD(r1,ProductSD(t1,ProductSD(r2,ProductSD(t2,ProductSD(r3,t3)))));
        gh1:=ProductSD(InverseSD(r1),ProductSD(InverseSD(t1),ProductSD(InverseSD(r2),ProductSD(InverseSD(t2),ProductSD(InverseSD(r3),InverseSD(t3))))));
        gh2:=ProductSD(InverseSD(t3),ProductSD(InverseSD(r3),ProductSD(InverseSD(t2),ProductSD(InverseSD(r2),ProductSD(InverseSD(t1),InverseSD(r1))))));
        h2:=ProductSD(gh1,gh2);
        hh2:=PowerSD(h2,Eo);
          if IsIdentitySD(Snew,hh2) then
            z:=ProductSD(PowerSD(h2,((Eo+1)/2)),g2);
          else
            z:=InvoEvenSD(Snew,hh2);
          fi;
        list[a]:=z;
      od;
  fi;
found:=false;
  while not found do
    if parpar then
      g:=PseudoRandomSD(list);
      g:=PowerSD(g,Eo);
        if (not IsIdentitySD(Snew,g)) and IsIdentitySD(Snew,PowerSD(g,2)) then
          found2:=false;
          r1:=PseudoRandomCyclicSD(r);
          t1:=PseudoRandomCyclicSD(t);
            if (not IsIdentitySD(Snew,r1)) and (not IsIdentitySD(Snew,t1)) then
              vi:=CentralizerInvoSD(Snew,g,Eo);
              found3:=false;
                while not found3 do
                  g:=PseudoRandomSD(vi);
                  g:=PowerSD(g,Eo);
                    if (not IsIdentitySD(Snew,g)) and (not IsIdentitySD(Snew,PowerSD(g,2))) then
                      vi:=[g,r1];;
                      found4:=false;
                      a:=1;
                        while (not found4) and (a <= 20) do
                          g2:=PseudoRandomSD(vi);
                            if IsIdentitySD(Snew,g2) then
                              a:=a+1;
                            else
                              g2:=InvoSubSD(Snew,vi,Eo);
                              if IsIdentitySD(Snew,g2) and EquivalentInSD(Snew,ConjugationSD(r1,g2),InverseSD(r1)) and EquivalentInSD(Snew,ConjugationSD(t1,g2),InverseSD(t1)) then
                                return [false,g2];
                              fi;
                            fi;
                        od;
                    else
                        found3:=true;
                    fi;
                od;
            fi;
        fi;
    else
      g:=TorusRandomSD(Snew,list);
      gg:=PowerSD(g,Eo);
        if (not IsIdentitySD(Snew,gg)) then
          return [false,InvoEvenSD(Snew,gg)];
        fi;
    fi;
  od;
end;
###################################################################
###################################################################
IntersectionLinesPSF:=function(Snew,i1,i2,j1,j2,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "i1", "i2", "j1", "j2" are projective points;
# "Eo" is the odd part of an exponent of the group.
# This function returns the point of intersection of the lines l1 and l2 determined by the projective points i1,i2 and j1,j2, respectively.

local z1,z2;

z1:=ReificationSD(Snew,i1,i2,Eo);
z2:=ReificationSD(Snew,j1,j2,Eo);
return ReificationSD(Snew,z1,z2,Eo);
end;
###################################################################
###################################################################
PermijkSD:=function(Snew,i,j,Eo)
# "Snew" is the output of "SetUpForPGL2";
# "i" and "j" are commuting conjugate involutions.
# "Eo" is the odd part of an exponent of the group.
# This function returns an element of order 3 in the normaliser of < i,j,i*j >. The output conjugates in the following way: i--> j --> i*j --> i.

local g1,g2,g3,finished,g,h1,h2,h3,t1,y1,f1,z1,u1;

g1:=i;
g2:=j;
g3:=ProductSD(i,j);
finished:=false;
  while not finished do
    g:=PseudoRandomPGL2(Snew);
    h1:=ConjugationSD(g1,g);
    h2:=ConjugationSD(g2,g);
    h3:=ConjugationSD(g3,g);
      if IsIdentitySD(Snew,PowerSD(ProductSD(g1,h2),Eo)) then
        t1:=ProductSD(g1,h2);
        y1:=PowerSD(t1,((Eo+1)/2));
        f1:=ConjugationSD(g3,ProductSD(g,InverseSD(y1)));
          if IsIdentitySD(Snew,PowerSD(ProductSD(g2,f1),Eo)) then
            finished:=true;
            z1:=ProductSD(g2,f1);
            u1:=PowerSD(z1,((Eo+1)/2));
          else
            finished:=false;
          fi;
      else
        finished:=false;
      fi;
  od;
return PowerSD(ProductSD(ProductSD(g,InverseSD(y1)),InverseSD(u1)),2);
end;
###################################################################
###################################################################
UnitElementsSD:=function(Snew,i,j,k,ti,elt3,Eo)
    # "Snew" is the output of "SetUpForPGL2";
    # "i,j,k" are involutions determining a basis triangle for the projective geometry;
    # "ti" is an element of order 4 in C_G(i) whose square is "i";
    # "elt3" is an element of order 3 permuting "i,j,k";
    # This function returns a list [P1,P2,P3,Q] where "P1,P2,P3" are unit elements on the lines "j v k", "i v k" and "i v j", respectively; and
    # "Q" is the projective point corresponding to (1,1,1).

    local G,ldi,ldj,ldk,a,mij,mik,mjk,di,dj,dk,g,a1,a2,a3,a4,a5,a6,b1,b2,b3,b4,b5,b6,b7,b8,c1,c2,c3,d1,d2,d3,d4,d5,d6;

    a1:=ti;
    b1:=elt3;
    a2:=PowerSD(ti,3);
    a3:=ConjugationSD(a1,b1);
    a4:=InverseSD(a3);
    b2:=PowerSD(elt3,2);
    c1:=PowerSD(ti,2);
    d1:=ProductSD(a4,c1);
    c2:=ProductSD(d1,a3);
    d2:=ConjugationSD(d1,c1);
    d3:=ConjugationSD(d2,a1);
    d4:=ProductSD(d3,c2);
    b3:=ProductSD(d1,a2);
    b4:=InverseSD(b3);
    b5:=ProductSD(d4,a4);
    b6:=InverseSD(b5);
    a5:=ProductSD(d4,c1);
    a6:=InverseSD(a5);
    b7:=ProductSD(a2,d2);
    b8:=InverseSD(b7);
    d5:=ProductSD(b6,d1);
    d6:=ProductSD(d1,b8);
    c3:=ProductSD(d2,d1);
    G:=[a1,a2,a3,a4,a5,a6,b1,b2,b3,b4,b5,b6,b7,b8,c1,c2,c3,d1,d2,d3,d4,d5,d6];

    ldi:=[];
    ldj:=[];
    ldk:=[];
    a:=1;
      for g in G do
        if (EquivalentInSD(Snew,ConjugationSD(j,g),k)) and (IsIdentitySD(Snew,ProductSD(g,g))) then
          ldi[a]:=g;
          a:=a+1;
        fi;
      od;
    a:=1;
      for g in G do
        if (EquivalentInSD(Snew,ConjugationSD(i,g),k)) and (IsIdentitySD(Snew,ProductSD(g,g))) then
          ldj[a]:=g;
          a:=a+1;
        fi;
      od;
    a:=1;
      for g in G do
        if (EquivalentInSD(Snew,ConjugationSD(j,g),i)) and (IsIdentitySD(Snew,ProductSD(g,g))) then
          ldk[a]:=g;
          a:=a+1;
        fi;
      od;
    di:=ldi[1];
    dj:=ldj[1];
    dk:=ldk[1];
    if not EquivalentInSD(Snew,ConjugationSD(j,di),k) then
      di:=ldi[2];
        if not EquivalentInSD(Snew,ConjugationSD(i,dj),k) then
          dj:=ldj[2];
            if not EquivalentInSD(Snew,ConjugationSD(di,dj),dk) then
              dk:=ldk[2];
            fi;
        fi;
    else
      if not EquivalentInSD(Snew,ConjugationSD(i,dj),k) then
        dj:=ldj[2];
          if not EquivalentInSD(Snew,ConjugationSD(di,dj),dk) then
            dk:=ldk[2];
          fi;
      else
        if not EquivalentInSD(Snew,ConjugationSD(di,dj),dk) then
          dk:=ldk[2];
        fi;
      fi;
    fi;

    mij:=IntersectionLinesPSF(Snew,[false,i],[false,di],[false,k],[false,dk],Eo);
    return [di,dj,dk,mij];
    end;
###################################################################
###################################################################
ToolBoxSL2:=function(S,E)
# "S" is a generating set for (P)SL2;
# "E" is an exponent for the group.
# This function returns a list which contains the fundamentals of a black box projective space and a black box field:
# 1- The output of "SetUpForPGL2", Snew;
# 2- Generating set for our semidirect product isomorphic to PGL2, Ss;
# 3,4,5- Three commuting involutions forming the vertices of the projective plane;
# 6- An element of order 3 permuting the three commuting involutions;
# 7,8,9- A unity element on the corresponding coordinate axes;
# 10- Centralizer of a fixed involution which is a vertex. Note that the black box field is constructed on the corresponding axis;
# 11- A point which serves as 0 in the black box field;
# 12- The projective point corresponding to (1,1,1);
# 13- Odd part of the exponent for the original group;
# 14- Binary representation of the odd part of the exponent;
# 15- An element of order 4 in the item 10 whose square is the corresponding involution.
# 16- Identity of the group.

local Snew,Ss,g,id,L,a,Ee,Eo,finished,i1,vi1,found,ti1,count,j1,vj1,tj1,k1,expodd,elt3,m,di1,dj1,dk1,mid,zero,zc;

###############
# Finding the odd and even part of the exponent "E".
###############
L:=E;
a:=0;
finished:=false;
  while not finished do
    if L mod 2 = 0 then
      L:=L/2;
      a:=a+1;
    else
      finished:=true;
    fi;
  od;
Ee:=a;
Eo:=E/(2^Ee);
expodd:=BinaryRep(Eo);
##############
# Exponent is decomposed into odd and even part.
##############
##############
# Constructing new generators for the semidirect product.
##############
Snew:=SetUpForPGL2(S,Eo);
Ss:=GeneratorsPGL2(Snew);

finished:=false;
  while not finished do
    i1:=InvoSD(Snew,Eo);
    vi1:=CentralizerInvoSD(Snew,i1,Eo);
    found:=false;
    count:=1;
      while (not found) and (count<=20) do
        ti1:=PseudoRandomSD(vi1);
          if 4DividesOrderSD(Snew,ti1,Eo) then
            found:=true;
            finished:=true;
          else
            count:=count+1;
          fi;
      od;
  od;
finished:=false;
  while not finished do
    j1:=InvoSubSD(Snew,vi1,Eo);
      if not EquivalentInSD(Snew,j1,i1) then
        vj1:=CentralizerInvoInSubgroupSD(Snew,Ss,j1,Eo);
        found:=false;
        count:=1;
          while (not found) and (count <=20) do
            tj1:=PseudoRandomSD(vj1);
              if 4DividesOrderSD(Snew,tj1,Eo) then
                found:=true;
                finished:=true;
              else
                count:=count+1;
              fi;
          od;
      fi;
  od;
k1:=ProductSD(i1,j1);
elt3:=PermijkSD(Snew,i1,j1,Eo);;
ti1:=ElementOrder4SD(Snew,ti1,Eo);
m:=UnitElementsSD(Snew,i1,j1,k1,ti1,elt3,Eo);
di1:=[false,m[1]];
dj1:=[false,m[2]];
dk1:=[false,m[3]];
mid:=m[4];
zero:=[false,j1];
zc:=Invo(S,Eo);
id:=zc^4;
id:=[id,id,0];;
return [Snew,Ss,[false,i1],[false,j1],[false,k1],elt3,di1,dj1,dk1,vi1,zero,mid,Eo,expodd,ti1,id];
end;
###################################################################
###################################################################
EquivalentInBBF:=function(Snew,g,h)
# "Snew" is the output of "SetUpForPGL2";
# "g" and "h" are elements from our black box field.
# This function returns the truth value whether the elements "g" and "h" are representing the same element in the black box field.

  if g[1] <> h[1] then
    return false;
  elif (g[1]=false) and (h[1]=false) and (not EquivalentInSD(Snew,g[2],h[2])) then
    return false;
  elif (g[1]=true) and (h[1]=true) and (not EquivalentInSD(Snew,ProductSD(g[4],h[4]),ProductSD(h[4],g[4]))) then
    return false;
  else
    return true;
  fi;
end;
###################################################################
###################################################################
AdditionBBF:=function(LL,a,b)
# "LL" is the output of "ToolBoxSL2";
# "a" and "b" are elements from our black box field.
# This function returns the sum of the two elements "a" and "b" in our black box field.

local Snew,i1,j1,k1,mid,Eo,aprime,bprime,ab,se;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
mid:=LL[12];
Eo:=LL[13];
  if EquivalentInBBF(Snew,a,j1) then
    return b;
  elif EquivalentInBBF(Snew,b,j1) then
    return a;
  else
    aprime:=IntersectionLinesPSF(Snew,i1,a,mid,k1,Eo);
    se:=IntersectionLinesPSF(Snew,mid,k1,i1,j1,Eo);
    bprime:=IntersectionLinesPSF(Snew,i1,k1,b,se,Eo);
    return IntersectionLinesPSF(Snew,j1,k1,aprime,bprime,Eo);
  fi;
end;
###################################################################
###################################################################
AdditiveInverseBBF:=function(LL,a)
# "LL" is the output of "ToolBoxSL2";
# "a" is an element from our black box field.
# This function returns the additive inverse of "a" in our black box field.

local Snew,j1;

Snew:=LL[1];
j1:=LL[4];

  if EquivalentInBBF(Snew,a,j1) then
    return j1;
  elif a[1]=false then
    return [false,ConjugationSD(a[2],j1[2])];
  else
    return [true,ConjugationSD(a[2],j1[2]),ConjugationSD(a[3],j1[2]),ConjugationSD(a[4],j1[2])];
  fi;
end;
###################################################################
###################################################################
MultiplicationBBF:=function(LL,a,b)
# "LL" is the output of "ToolBoxSL2";
# "a" and "b" are elements from our black box field.
# This function returns the product of the two elements "a" and "b" in our black box field.

local Snew,i1,j1,k1,di1,mid,Eo,aprime,bprime,ab;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
di1:=LL[7];
mid:=LL[12];
Eo:=LL[13];
  if EquivalentInBBF(Snew,a,di1) then
    return b;
  elif EquivalentInBBF(Snew,b,di1) then
    return a;
  elif EquivalentInBBF(Snew,a,j1) or EquivalentInBBF(Snew,b,j1) then
    return j1;
  else
   aprime:=IntersectionLinesPSF(Snew,i1,a,j1,mid,Eo);
   bprime:=IntersectionLinesPSF(Snew,b,mid,i1,k1,Eo);
   return IntersectionLinesPSF(Snew,aprime,bprime,j1,k1,Eo);
  fi;
end;
###################################################################
###################################################################
MultiplicativeInverseBBF:=function(LL,a)
# "LL" is the output of "ToolBoxSL2";
# "a" is an element from our black box field.
# This function returns the multiplicative inverse of "a" in our black box field.

local Snew,di1;

Snew:=LL[1];
di1:=LL[7];
  if EquivalentInBBF(Snew,a,di1) then
    return di1;
  elif a[1]=false then
    return [false,ConjugationSD(a[2],di1[2])];
  else
    return [true,ConjugationSD(a[2],di1[2]),ConjugationSD(a[3],di1[2]),ConjugationSD(a[4],di1[2])];
  fi;
end;
###################################################################
###################################################################
PowerBinaryRepBBF:=function(LL,a,l)
# "LL" is the output of "ToolBoxSL2".
# "a" is an element from our black box field.
# "l" is a list consisting of natural numbers.
# This function returns the power a^{2^l[1] + 2^l[2] + ... + 2^l[r]}.

local di1,M,0in,x,k,i,y,f,ll;

di1:=LL[7];
M:=Maximum(l);
  if 0 in l then
    0in:=true;
  else
    0in:=false;
  fi;
ll:=[];
x:=a;
k:=1;
  for i in [1..M] do
    if i in l then
      x:=MultiplicationBBF(LL,x,x);
      ll[k]:=x;
      k:=k+1;
    else
      x:=MultiplicationBBF(LL,x,x);
    fi;
  od;
  if Length(ll)=0 then
    return di1;
  else
    y:=ll[1];
      for f in [2..(k-1)] do
        y:=MultiplicationBBF(LL,y,ll[f]);
      od;
  fi;
  if 0in=true then
    return MultiplicationBBF(LL,y,a);
  else
    return y;
  fi;
end;
###################################################################
###################################################################
2HeightBBF:=function(LL,a)
# "LL" is the output of "ToolBoxSL2";
# "a" is an element from our black box field.
# This function returns the 2-height of the black box field element "a", that is, the maximum power of 2 appears in the multiplicative order of "a".

local Snew,di1,expodd,finished,count,aa,aaa;

Snew:=LL[1];
di1:=LL[7];
expodd:=LL[14];
finished:=false;
count:=0;
aa:=PowerBinaryRepBBF(LL,a,expodd);
aaa:=aa;
  while not finished do
    if EquivalentInBBF(Snew,aa,di1) then
      finished:=true;
    else
      aa:=MultiplicationBBF(LL,aa,aa);
      count:=count+1;
    fi;
  od;
return [count,aaa];
end;
###################################################################
###################################################################
SquareRootBBF:=function(LL,n)
# "LL" is the output of "ToolBoxSL2";
# "n" is an element from our black box field.
# This function returns either a square root of the black box field element "n", if exists; or fails, otherwise. This is Tonelli-Shanks algorithm.

local Snew,i1,j1,k1,di1,vi1,Eo,expodd,Y,finished,finished2,g,YY,expA,R,M,t,a,b,c,count,zero,one;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
di1:=LL[7];
vi1:=LL[10];
Eo:=LL[13];
expodd:=LL[14];
zero:=LL[11];
one:=LL[7];

if EquivalentInBBF(LL,zero,n) then
Info(InfoSL2toBBG,1,"The element corresponds to 0 in the black box field.");
    return n;
elif EquivalentInBBF(LL,one,n) then
Info(InfoSL2toBBG,1,"The element corresponds to 1 in the black box field.");
    return n;
else

Y:=2HeightBBF(LL,n);
#Info(InfoSL2toBBG,1,"2height of the input is ", Y[1],".");
finished:=false;
count:=1;
Info(InfoSL2toBBG,1,"Testing whether it is a square or not.");
  while (not finished) and (count<=18) do
        if count=1 then
            Info(InfoSL2toBBG,1,"1st test.");
        elif count=2 then
            Info(InfoSL2toBBG,1,"2nd test.");
        elif count=3 then
            Info(InfoSL2toBBG,1,"3rd test.");
        else
            Info(InfoSL2toBBG,1,count,"th test.");
        fi;
    finished2:=false;
      while not finished2 do
        g:=PseudoRandomSD(vi1);
          if (not IsIdentitySD(Snew,g)) and (IsIdentitySD(Snew,PowerSD(g,2))) and (not EquivalentInSD(Snew,g,i1[2])) and (not EquivalentInSD(Snew,g,j1[2])) and (not EquivalentInSD(Snew,g,k1[2]))  then
            finished2:=true;
          fi;
      od;
    YY:=2HeightBBF(LL,[false,g]);
      if YY[1]>Y[1] then
        finished:=true;
      else
        count:=count+1;
      fi;
  od;
  if count=19 then
      Info(InfoSL2toBBG,1,"Square root does not exist for this element.");
    return false;
  fi;
Info(InfoSL2toBBG,1,"Test passed. Computing a square root.");
expA:=BinaryRep((Eo+1)/2);
R:=PowerBinaryRepBBF(LL,n,expA);
M:=YY[1];
t:=Y[2];
c:=YY[2];
finished:=false;
  while (not finished) do
    if EquivalentInSD(Snew,t[2],di1[2]) then
      return R;
    else
      a:=2HeightBBF(LL,t)[1];
          if ((M-a-1)=0) then
            b:=c;
          else
            b:=PowerBinaryRepBBF(LL,c,[(M-a-1)]);
          fi;
        M:=a;
        c:=MultiplicationBBF(LL,b,b);
        t:=MultiplicationBBF(LL,t,c);
        R:=MultiplicationBBF(LL,R,b);
      fi;
  od;
fi;
end;
###################################################################
###################################################################
MatrixMultiplication2x2BBF:=function(LL,g,h)
# "LL" is the output of "ToolBoxSL2";
# "g" and "h" are 2x2 matrices with entries (given as a list) from our black box field.
# This function returns a matrix which is the multiplication of the black box matrices "g" and "h".

local r,m1,m2;

r:=[];

m1:=MultiplicationBBF(LL,g[1],h[1]);
m2:=MultiplicationBBF(LL,g[2],h[3]);
r[1]:=AdditionBBF(LL,m1,m2);

m1:=MultiplicationBBF(LL,g[1],h[2]);
m2:=MultiplicationBBF(LL,g[2],h[4]);
r[2]:=AdditionBBF(LL,m1,m2);

m1:=MultiplicationBBF(LL,g[3],h[1]);
m2:=MultiplicationBBF(LL,g[4],h[3]);
r[3]:=AdditionBBF(LL,m1,m2);

m1:=MultiplicationBBF(LL,g[3],h[2]);
m2:=MultiplicationBBF(LL,g[4],h[4]);
r[4]:=AdditionBBF(LL,m1,m2);

return r;
end;
###################################################################
###################################################################
MatrixMultiplication3x3BBF:=function(LL,g,h)
# "LL" is the output of "ToolBoxSL2";
# "g" and "h" are 3x3 matrices with entries (given as a list) from our black box field.
# This function returns a matrix which is the multiplication of the black box matrices "g" and "h".

local r,m11,m12,m13,a11,a12;

r:=[];

m11:=MultiplicationBBF(LL,g[1],h[1]);
m12:=MultiplicationBBF(LL,g[2],h[4]);
m13:=MultiplicationBBF(LL,g[3],h[7]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[1]:=a12;

m11:=MultiplicationBBF(LL,g[1],h[2]);
m12:=MultiplicationBBF(LL,g[2],h[5]);
m13:=MultiplicationBBF(LL,g[3],h[8]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[2]:=a12;

m11:=MultiplicationBBF(LL,g[1],h[3]);
m12:=MultiplicationBBF(LL,g[2],h[6]);
m13:=MultiplicationBBF(LL,g[3],h[9]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[3]:=a12;


m11:=MultiplicationBBF(LL,g[4],h[1]);
m12:=MultiplicationBBF(LL,g[5],h[4]);
m13:=MultiplicationBBF(LL,g[6],h[7]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[4]:=a12;

m11:=MultiplicationBBF(LL,g[4],h[2]);
m12:=MultiplicationBBF(LL,g[5],h[5]);
m13:=MultiplicationBBF(LL,g[6],h[8]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[5]:=a12;

m11:=MultiplicationBBF(LL,g[4],h[3]);
m12:=MultiplicationBBF(LL,g[5],h[6]);
m13:=MultiplicationBBF(LL,g[6],h[9]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[6]:=a12;


m11:=MultiplicationBBF(LL,g[7],h[1]);
m12:=MultiplicationBBF(LL,g[8],h[4]);
m13:=MultiplicationBBF(LL,g[9],h[7]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[7]:=a12;

m11:=MultiplicationBBF(LL,g[7],h[2]);
m12:=MultiplicationBBF(LL,g[8],h[5]);
m13:=MultiplicationBBF(LL,g[9],h[8]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[8]:=a12;

m11:=MultiplicationBBF(LL,g[7],h[3]);
m12:=MultiplicationBBF(LL,g[8],h[6]);
m13:=MultiplicationBBF(LL,g[9],h[9]);
a11:=AdditionBBF(LL,m11,m12);
a12:=AdditionBBF(LL,a11,m13);
r[9]:=a12;

return r;
end;
###################################################################
###################################################################
Equivalent2x2MatricesBBF:=function(Snew,g,h)
# "Snew" is the output of "SetUpForPGL2";
# "g" and "h" are 3x3 matrices with entries (given as a list) from our black box field.
# This function returns the truth value whether the two 3x3 matrices "g" and "h" are equal to each other.

local a;
  for a in [1..4] do
    if (not EquivalentInBBF(Snew,g[a], h[a]) ) then
      return false;
    fi;
  od;
return true;
end;
###################################################################
###################################################################
Equivalent2x2ProjectiveMatricesBBF:=function(LL,g,h)
# "Snew" is the output of "SetUpForPGL2";
# "g" and "h" are 3x3 matrices with entries (given as a list) from our black box field.
# This function returns the truth value whether the two 3x3 matrices "g" and "h" are equal to each other.

local Snew,a,x;

Snew:=LL[1];
    if (not EquivalentInBBF(Snew,g[1], h[1]) ) then
        x:=MultiplicationBBF(LL,g[1], MultiplicativeInverseBBF(LL,h[1]));
            for a in [2..4] do
                if (not EquivalentInBBF(Snew,g[a], MultiplicationBBF(LL, x, h[a]))) then
                    return false;
                fi;
            od;
    else
        for a in [2..4] do
            if (not EquivalentInBBF(Snew,g[a], h[a])) then
                return false;
            fi;
        od;
    fi;
return true;
end;
###################################################################
###################################################################
Equivalent3x3MatricesBBF:=function(Snew,g,h)
# "Snew" is the output of "SetUpForPGL2";
# "g" and "h" are 3x3 matrices with entries (given as a list) from our black box field.
# This function returns the truth value whether the two 3x3 matrices "g" and "h" are equal to each other.

local a;
  for a in [1..9] do
    if (not EquivalentInBBF(Snew,g[a], h[a]) ) then
      return false;
    fi;
  od;
return true;
end;
###################################################################
###################################################################
Determinant2x2BBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is a 2x2 matrix with entries (given as a list) from our black box field.
# This function returns a black box field element which is the determinant of the black box matrix "g".
#NotUsed.

local A1,A2,A3,A4;

A1:=MultiplicationBBF(LL,g[1],g[4]);
A2:=MultiplicationBBF(LL,g[2],g[3]);
A3:=AdditiveInverseBBF(LL,A2);
A4:=AdditionBBF(LL,A1,A3);
return A4;
end;
###################################################################
###################################################################
Determinant3x3BBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is a 3x3 matrix with entries (given as a list) from our black box field.
# This function returns a black box field element which is the determinant of the black box matrix "g".

local A1,A2, A3,A4,B1,B2,B3,B4,B5,C1,C2,C3,C4,D1,D2,j1;

j1:=LL[4];

A1:=MultiplicationBBF(LL,g[5],g[9]);
A2:=MultiplicationBBF(LL,g[6],g[8]);
  if A2[1]=false then
    A3:=AdditionBBF(LL,A1,[false,ConjugationSD(A2[2],j1[2])]);
  else
    A3:=AdditionBBF(LL,A1,[true,ConjugationSD(A2[2],j1[2]),ConjugationSD(A2[3],j1[2]),ConjugationSD(A2[4],j1[2])]);
  fi;
A4:=MultiplicationBBF(LL,g[1],A3);

B1:=MultiplicationBBF(LL,g[4],g[9]);
B2:=MultiplicationBBF(LL,g[7],g[6]);
  if B2[1]=false then
    B3:=AdditionBBF(LL,B1,[false,ConjugationSD(B2[2],j1[2])]);
  else
    B3:=AdditionBBF(LL,B1,[true,ConjugationSD(B2[2],j1[2]),ConjugationSD(B2[3],j1[2]),ConjugationSD(B2[4],j1[2])]);
  fi;
B4:=MultiplicationBBF(LL,g[2],B3);
  if B4[1]=false then
    B5:=[false,ConjugationSD(B4[2],j1[2])];
  else
    B5:=[true,ConjugationSD(B4[2],j1[2]),ConjugationSD(B4[3],j1[2]),ConjugationSD(B4[4],j1[2])];
  fi;

C1:=MultiplicationBBF(LL,g[4],g[8]);
C2:=MultiplicationBBF(LL,g[5],g[7]);
  if C2[1]=false then
    C3:=AdditionBBF(LL,C1,[false,ConjugationSD(C2[2],j1[2])]);
  else
    C3:=AdditionBBF(LL,C1,[true,ConjugationSD(C2[2],j1[2]),ConjugationSD(C2[3],j1[2]),ConjugationSD(C2[4],j1[2])]);
  fi;
C4:=MultiplicationBBF(LL,g[3],C3);

D1:=AdditionBBF(LL,A4,B5);
D2:=AdditionBBF(LL,D1,C4);

return D2;
end;
###################################################################
###################################################################
HomogenousCoordinatesBBF:=function(LL,P)
# "LL" is the output of "ToolBoxSL2";
# "P" is a black box projective point.
# This function returns the homogenous coordinates of the point "P" where its z-coordinate is set as 1.

local Snew,i1,j1,k1,di1,dj1,Eo,Px,Py;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
di1:=LL[7];
dj1:=LL[8];
Eo:=LL[13];

Px:=IntersectionLinesPSF(Snew,P,i1,j1,k1,Eo);
Py:=IntersectionLinesPSF(Snew,P,k1,i1,j1,Eo);
  if Py[1]=false then
    Py:=[false,ConjugationSD(Py[2],dj1[2])];
  else
    Py:=[true,ConjugationSD(Py[2],dj1[2]),ConjugationSD(Py[3],dj1[2]),ConjugationSD(Py[4],dj1[2])];
  fi;
return [Px,Py,di1];
end;
###################################################################
###################################################################
ColumnBBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is a black box projective point.
# This function returns the corresponding column from the projective point "g" in the construction of SO3 over our black box field.

local Snew,j1,di1,Eo,gh,gx,gy,gxsq,gysq,A,B,C,D,gX,gY,gZ,cgh,found,h;

Snew:=LL[1];
j1:=LL[4];
di1:=LL[7];
Eo:=LL[13];

if (not EquivalentInSD(Snew,ProductSD(g[2],j1[2]),ProductSD(j1[2],g[2]))) then
  gh:=HomogenousCoordinatesBBF(LL,g);
  gx:=gh[1];
  gy:=gh[2];
  gxsq:=MultiplicationBBF(LL,gx,gx);
  gysq:=MultiplicationBBF(LL,gy,gy);
  A:=AdditionBBF(LL,gxsq,gysq);
  B:=AdditionBBF(LL,A,di1);
    if B[1]=false then
      C:=[false,ConjugationSD(B[2],di1[2])];
    else
      C:=[true,ConjugationSD(B[2],di1[2]),ConjugationSD(B[3],di1[2]),ConjugationSD(B[4],di1[2])];
    fi;
  D:=SquareRootBBF(LL,C);
    if D[1]=false then
      gX:=MultiplicationBBF(LL,gx,[false,D[2]]);
      gY:=MultiplicationBBF(LL,gy,[false,D[2]]);
      gZ:=MultiplicationBBF(LL,di1,[false,D[2]]);
    else
      gX:=MultiplicationBBF(LL,gx,[true,D[2],D[3],D[4]]);
      gY:=MultiplicationBBF(LL,gy,[true,D[2],D[3],D[4]]);
      gZ:=MultiplicationBBF(LL,di1,[true,D[2],D[3],D[4]]);
    fi;
else

  gh:=ReificationSD(Snew,j1,g,Eo);
  cgh:=CentralizerInvoSD(Snew,gh[2],Eo);
  found:=false;
    while not found do
      h:=PseudoRandomSD(cgh);
      if (not IsIdentitySD(Snew,h)) and (IsIdentitySD(Snew,PowerSD(h,2))) and (not EquivalentInSD(Snew,h,j1[2])) and (not EquivalentInSD(Snew,h,gh[2])) and (not EquivalentInSD(Snew,h,g[2])) then
        found:=true;
      fi;
    od;
  gh:=HomogenousCoordinatesBBF(LL,[false,h]);
  gx:=gh[1];
  gy:=gh[2];
  gxsq:=MultiplicationBBF(LL,gx,gx);
  gysq:=MultiplicationBBF(LL,gy,gy);
  A:=AdditionBBF(LL,gxsq,gysq);
    if A[1]=false then
      C:=[false,ConjugationSD(A[2],di1[2])];
    else
      C:=[true,ConjugationSD(A[2],di1[2]),ConjugationSD(A[3],di1[2]),ConjugationSD(A[4],di1[2])];
    fi;
  D:=SquareRootBBF(LL,C);
    if D[1]=false then
      gX:=MultiplicationBBF(LL,gx,[false,D[2]]);
      gY:=MultiplicationBBF(LL,gy,[false,D[2]]);
      gZ:=j1;
    else
      gX:=MultiplicationBBF(LL,gx,[true,D[2],D[3],D[4]]);
      gY:=MultiplicationBBF(LL,gy,[true,D[2],D[3],D[4]]);
      gZ:=j1;
    fi;
fi;

return [gX,gY,gZ];

end;
###################################################################
###################################################################
InvoMatrixGeneralBBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is an involution for our semidirect product isomorphic to PGL2.
# This function returns the image of the involution "g" where "g" does not commute with coordinate involutions.

local Snew,i1,j1,k1,di1,u,v,w,U,V,W,det,Z;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
di1:=LL[7];

v:=[false,ConjugationSD(i1[2],g)];
u:=[false,ConjugationSD(k1[2],g)];
w:=[false,ConjugationSD(j1[2],g)];

U:=ColumnBBF(LL,u);
V:=ColumnBBF(LL,v);
W:=ColumnBBF(LL,w);

  if (V[1][1]=false) and (not EquivalentInSD(Snew,U[2][2],V[1][2])) then
    if (EquivalentInSD(Snew,ConjugationSD(V[1][2],j1[2]), U[2][2])) then
      V[1]:=[false, ConjugationSD(V[1][2],j1[2])];
        if V[2][1]=false then
          V[2]:=[false,ConjugationSD(V[2][2],j1[2])];
        else
          V[2]:=[true,ConjugationSD(V[2][2],j1[2]),ConjugationSD(V[2][3],j1[2]),ConjugationSD(V[2][4],j1[2])];
        fi;
        if V[3][1]=false then
          V[3]:=[false,ConjugationSD(V[3][2],j1[2])];
        else
          V[3]:=[true,ConjugationSD(V[3][2],j1[2]),ConjugationSD(V[3][3],j1[2]),ConjugationSD(V[3][4],j1[2])];
        fi;
    fi;
  elif (V[1][1]=true) and (not EquivalentInSD(Snew,ProductSD(U[2][4],V[1][4]),ProductSD(V[1][4],U[2][4]))) then
    if EquivalentInSD(Snew,ProductSD(U[2][4],ConjugationSD(V[1][4],j1[2])),ProductSD(ConjugationSD(V[1][4],j1[2]),U[2][4])) then
      V[1]:=[true, ConjugationSD(V[1][2],j1[2]),ConjugationSD(V[1][3],j1[2]),ConjugationSD(V[1][4],j1[2])];
        if V[2][1]=false then
          V[2]:=[false,ConjugationSD(V[2][2],j1[2])];
        else
          V[2]:=[true,ConjugationSD(V[2][2],j1[2]),ConjugationSD(V[2][3],j1[2]),ConjugationSD(V[2][4],j1[2])];
        fi;
        if V[3][1]=false then
          V[3]:=[false,ConjugationSD(V[3][2],j1[2])];
        else
          V[3]:=[true,ConjugationSD(V[3][2],j1[2]),ConjugationSD(V[3][3],j1[2]),ConjugationSD(V[3][4],j1[2])];
        fi;
    fi;
  fi;

  if (W[1][1]=false) and (not EquivalentInSD(Snew, U[3][2], W[1][2])) then
    if EquivalentInSD(Snew, ConjugationSD(W[1][2],j1[2]), U[3][2]) then
      W[1]:=[false, ConjugationSD(W[1][2],j1[2])];
        if W[2][1]=false then
          W[2]:=[false,ConjugationSD(W[2][2],j1[2])];
        else
          W[2]:=[true,ConjugationSD(W[2][2],j1[2]),ConjugationSD(W[2][3],j1[2]),ConjugationSD(W[2][4],j1[2])];
        fi;
        if W[3][1]=false then
          W[3]:=[false,ConjugationSD(W[3][2],j1[2])];
        else
          W[3]:=[true,ConjugationSD(W[3][2],j1[2]), ConjugationSD(W[3][3],j1[2]), ConjugationSD(W[3][4],j1[2])];
        fi;
    fi;
  elif (W[1][1]=true) and (not EquivalentInSD(Snew, ProductSD(U[3][4],W[1][4]), ProductSD(W[1][4],U[3][4]))) then
    if (EquivalentInSD(Snew, ProductSD(U[3][4],ConjugationSD(W[1][4],j1[2])), ProductSD(ConjugationSD(W[1][4],j1[2]),U[3][4]))) then
      W[1]:=[true, ConjugationSD(W[1][2],j1[2]),ConjugationSD(W[1][3],j1[2]),ConjugationSD(W[1][4],j1[2])];
        if W[2][1]=false then
          w[2]:=[false,ConjugationSD(W[2][2],j1[2])];
        else
          W[2]:=[true,ConjugationSD(W[2][2],j1[2]),ConjugationSD(W[2][3],j1[2]),ConjugationSD(W[2][4],j1[2])];
        fi;
        if W[3][1]=false then
          W[3]:=[false,ConjugationSD(W[3][2],j1[2])];
        else
          W[3]:=[true,ConjugationSD(W[3][2],j1[2]),ConjugationSD(W[3][3],j1[2]),ConjugationSD(W[3][4],j1[2])];
        fi;
    fi;
  fi;
      Info(InfoSL2toBBG,1,"Making the determinant right.");
  Z:=[U[1],U[2],U[3],V[1],V[2],V[3],W[1],W[2],W[3]];
  det:=Determinant3x3BBF(LL,Z);
  if EquivalentInBBF(Snew,det,di1) then
    return  [U[1],U[2],U[3],V[1],V[2],V[3],W[1],W[2],W[3]];
  elif EquivalentInBBF(Snew,det,AdditiveInverseBBF(LL,di1)) then
    U[1]:=AdditiveInverseBBF(LL,U[1]);
    U[2]:=AdditiveInverseBBF(LL,U[2]);
    U[3]:=AdditiveInverseBBF(LL,U[3]);
    V[2]:=AdditiveInverseBBF(LL,V[2]);
    V[3]:=AdditiveInverseBBF(LL,V[3]);
    W[3]:=AdditiveInverseBBF(LL,W[3]);
    return [U[1],U[2],U[3],U[2],V[2],V[3],U[3],V[3],W[3]];
  fi;
end;
###################################################################
###################################################################
InvoMatrixSpecialBBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is an involution for our semidirect product isomorphic to PGL2.
# This function returns the image of the involution "g" where "g" commutes with one of the coordinate involutions.

local Snew,i1,j1,k1,Eo,found,h,z,imh,imz,m1,m2;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
Eo:=LL[13];
found:=false;
  while not found do
    h:=InvoSD(Snew,Eo);
      if (not EquivalentInSD(Snew, ProductSD(h,i1[2]), ProductSD(i1[2],h))) and (not EquivalentInSD(Snew, ProductSD(h,j1[2]), ProductSD(j1[2],h))) and (not EquivalentInSD(Snew, ProductSD(h,k1[2]),ProductSD(k1[2],h))) then
        z:=ConjugationSD(g,h);
          if (not EquivalentInSD(Snew, ProductSD(z,i1[2]), ProductSD(i1[2],z))) and (not EquivalentInSD(Snew, ProductSD(z,j1[2]), ProductSD(j1[2],z))) and (not EquivalentInSD(Snew, ProductSD(z,k1[2]), ProductSD(k1[2],z))) then
            found:=true;
            imh:=InvoMatrixGeneralBBF(LL,h);
            imz:=InvoMatrixGeneralBBF(LL,z);
            m1:=MatrixMultiplication3x3BBF(LL,imh,imz);
            m2:=MatrixMultiplication3x3BBF(LL,m1,imh);
            return m2;
          fi;
      fi;
  od;
end;
###################################################################
###################################################################
BBGtoSO3InvoBBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is an involution for our semidirect product isomorphic to PGL2.
# This function returns the image of the involution "g".

local Snew,i1,j1,k1,di1,zero;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
di1:=LL[7];
zero:=LL[11];
  if EquivalentInSD(Snew, g, i1[2]) then
    return [di1,zero,zero,zero,[false,ConjugationSD(di1[2],j1[2])],zero,zero,zero,[false,ConjugationSD(di1[2],j1[2])]];
  elif EquivalentInSD(Snew, g, j1[2]) then
    return [[false,ConjugationSD(di1[2],j1[2])],zero,zero,zero,di1,zero,zero,zero,[false,ConjugationSD(di1[2],j1[2])]];
  elif EquivalentInSD(Snew, g, k1[2]) then
    return [[false,ConjugationSD(di1[2],j1[2])],zero,zero,zero,[false,ConjugationSD(di1[2],j1[2])],zero,zero,zero,di1];
  elif (not EquivalentInSD(Snew, ProductSD(g,i1[2]), ProductSD(i1[2],g))) and (not EquivalentInSD(Snew, ProductSD(g,j1[2]), ProductSD(j1[2],g))) and (not EquivalentInSD(Snew, ProductSD(g,k1[2]), ProductSD(k1[2],g))) then
    return InvoMatrixGeneralBBF(LL,g);
  elif EquivalentInSD(Snew, ProductSD(g,i1[2]), ProductSD(i1[2],g)) or EquivalentInSD(Snew, ProductSD(g,j1[2]), ProductSD(j1[2],g)) or EquivalentInSD(Snew, ProductSD(g,k1[2]), ProductSD(k1[2],g)) then
    Info(InfoSL2toBBG,1,"We need to work with an involution which is in special position.");
    return InvoMatrixSpecialBBF(LL,g);
  fi;
end;
###################################################################
###################################################################
RowAsBlackBoxElementBBF:=function(LL,m)
# "LL" is the output of "ToolBoxSL2";
# "m" is a list corresponding to a row in the group SO3 over our black box field.
# This function returns a projective point whose homogenous coordinates is this row.

local Snew,i1,j1,k1,di1,dj1,Eo,s,r1r,r11,r12;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
di1:=LL[7];
dj1:=LL[8];
Eo:=LL[13];

if EquivalentInBBF(Snew,m[3],di1) then
  if m[2][1]=false then
    s:=IntersectionLinesPSF(Snew,i1,m[1],k1,[false,ConjugationSD(m[2][2],dj1[2])],Eo);
  else
    s:=IntersectionLinesPSF(Snew,i1,m[1],k1,[true, ConjugationSD(m[2][2],dj1[2]), ConjugationSD(m[2][3],dj1[2]), ConjugationSD(m[2][4],dj1[2])],Eo);
  fi;
elif EquivalentInBBF(Snew,m[3],j1) then
  if m[2][1]=false then
    s:=IntersectionLinesPSF(Snew,i1,m[1],k1,[false, ConjugationSD(m[2][2],dj1[2])],Eo);
    s:=IntersectionLinesPSF(Snew,j1,s,i1,k1,Eo);
  else
    s:=IntersectionLinesPSF(Snew,i1,m[1],k1,[true, ConjugationSD(m[2][2],dj1[2]), ConjugationSD(m[2][3],dj1[2]), ConjugationSD(m[2][4],dj1[2])],Eo);
    s:=IntersectionLinesPSF(Snew,j1,s,i1,k1,Eo);
  fi;
else
  r1r:=MultiplicativeInverseBBF(LL,m[3]);
  r11:=MultiplicationBBF(LL,m[1],r1r);
  r12:=MultiplicationBBF(LL,m[2],r1r);
    if r12[1]=false then
      s:=IntersectionLinesPSF(Snew,i1,r11,k1,[false,ConjugationSD(r12[2],dj1[2])],Eo);
    else
      s:=IntersectionLinesPSF(Snew,i1,r11,k1,[true, ConjugationSD(r12[2],dj1[2]), ConjugationSD(r12[3],dj1[2]), ConjugationSD(r12[4],dj1[2])],Eo);
    fi;
fi;
return s;
end;
###################################################################
###################################################################
SO3toBBGInvo:=function(LL,m)
# "LL" is the output of "ToolBoxSL2";
# "m" is an involution from the group SO3 over our black box field.
# This function returns the involution whose image is the black box matrix "m".

local Snew,Ss,i1,j1,k1,Eo,ck1,r1,r2,r3,s1,s2,s3,t1,t2,s,k,list,ll,g,uu1,uu2;

Snew:=LL[1];
Ss:=LL[2];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
Eo:=LL[13];
ck1:=CentralizerInvoSD(Snew,k1[2],Eo);
r1:=[];
r2:=[];
r3:=[];

r1:=[m[1],m[2],m[3]];
r2:=[m[4],m[5],m[6]];
r3:=[m[7],m[8],m[9]];

s1:=RowAsBlackBoxElementBBF(LL,r1);
s2:=RowAsBlackBoxElementBBF(LL,r2);
s3:=RowAsBlackBoxElementBBF(LL,r3);

t1:=ConjugatingInvoSD(Snew,Ss,k1[2],s1[2],Eo);
t2:=ConjugatingInvoSD(Snew,ck1,i1[2],ConjugationSD(s2[2],t1),Eo);
s:=ProductSD(t2,t1);

k:=1;
list:=[];
ll:=[s,ProductSD(i1[2],s),ProductSD(j1[2],s),ProductSD(k1[2],s)];
  for g in ll do
    if IsIdentitySD(Snew,PowerSD(g,2)) and (not IsIdentitySD(Snew,g)) then
      list[k]:=g;
      k:=k+1;
    fi;
  od;
if Length(list)=1 then
  return list[1];
else
  uu1:=BBGtoSO3InvoBBF(LL,list[1]);
    if Equivalent3x3MatricesBBF(Snew,uu1,m) then
      return list[1];
    else
      uu2:=BBGtoSO3InvoBBF(LL,list[2]);
        if Equivalent3x3MatricesBBF(Snew,uu2,m) then
          return list[2];
        else
          return false;
        fi;
    fi;
fi;
end;
###################################################################
###################################################################
PseudoRandomField:=function(LL)
# "LL" is the output of "ToolBoxSL2";
# This function returns a random element from our black box field. These elements are never unipotents, that is,
# we ignore the unipotent subgroups which serves in some cases as black box field elements.

local Snew,i1,j1,k1,T,found,g;

Snew:=LL[1];
i1:=LL[3];
j1:=LL[4];
k1:=LL[5];
T:=LL[10];
found:=false;
  while not found do
    g:=PseudoRandomSD(T);
      if IsIdentitySD(Snew,PowerSD(g,2)) and (not IsIdentitySD(Snew,g)) and (not EquivalentInSD(Snew,g,i1[2])) and (not EquivalentInSD(Snew,g,j1[2])) and (not EquivalentInSD(Snew,g,k1[2]))then
        return [false,g];
      fi;
  od;
end;
###################################################################
###################################################################
SharpVsFlat:=function(LL)
# "LL" is the output of "ToolBoxSL2";
# This function returns the change of basis from SO3-Sharp to SO3-Flat.

local di1,zero,m1,found,a,a2,ma2,b2,b,ma,mb,P,two,twoinv,a2b2,a2b2inv,twoa2b2inv,p4,p5,p6,p7,p8,p9,Pinv;

di1:=LL[7];
zero:=LL[11];
m1:=AdditiveInverseBBF(LL,di1);
found:=false;
  while not found do
    a:=PseudoRandomField(LL);
    a2:=MultiplicationBBF(LL,a,a);
    ma2:=AdditiveInverseBBF(LL,a2);
    b2:=AdditionBBF(LL,ma2,m1);
      if (not EquivalentInBBF(LL,b2,zero)) then
        Info(InfoSL2toBBG,1, "Computing the square root of a random black box field element of the form 1-x^2.");
        b:=SquareRootBBF(LL,b2);
          if b=false then
            found:=false;
          else
            found:=true;
          fi;
      fi;
  od;

ma:=AdditiveInverseBBF(LL,a);
mb:=AdditiveInverseBBF(LL,b);
P:=[di1,mb,a,zero,a,b,di1,b,ma];
two:=AdditionBBF(LL,di1,di1);
twoinv:=MultiplicativeInverseBBF(LL,two);
a2b2:=AdditionBBF(LL,a2,b2);
a2b2inv:=MultiplicativeInverseBBF(LL,a2b2);
twoa2b2inv:=MultiplicationBBF(LL,a2b2inv,twoinv);
p6:=MultiplicationBBF(LL,b,twoa2b2inv);
p4:=AdditiveInverseBBF(LL,p6);
p7:=MultiplicationBBF(LL,a,twoa2b2inv);
p9:=AdditiveInverseBBF(LL,p7);
p8:=MultiplicationBBF(LL,b,a2b2);
p5:=MultiplicationBBF(LL,a,a2b2inv);

Pinv:=[twoinv,zero,twoinv,p4,p5,p6,p7,p8,p9];

return [P,Pinv];
end;
###################################################################
###################################################################
UnipotentAsInvoProductsV1BBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is a unipotent element from SL(2,K) of the form [1,x,0,1] where "K" is our black box field.
# This function returns two involutions whose product gives the element "g".

local x,di1,zero,m1,xm1,o1,o2;

x:=g[2];
di1:=LL[7];
zero:=LL[11];
m1:=AdditiveInverseBBF(LL,di1);
xm1:=AdditionBBF(LL,x,m1);
o1:=[m1,xm1,zero,di1];
o2:=[m1,m1,zero,di1];
return [o1,o2];
end;
###################################################################
###################################################################
UnipotentAsInvoProductsV2BBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is a unipoten element from SL(2,K) of the form [1,0,x,1] where "K" is our black box field.
# This function returns two involutions whose product gives the element "g".

local x,di1,zero,m1,xm1,o1,o2;

x:=g[3];
di1:=LL[7];
zero:=LL[11];
m1:=AdditiveInverseBBF(LL,di1);
xm1:=AdditionBBF(LL,x,m1);
o1:=[di1,zero,xm1,m1];
o2:=[di1,zero,m1,m1];
return [o1,o2];
end;
###################################################################
###################################################################
ElementAsUnipotentProductsBBF:=function(LL,g)
# "LL" is the output of "ToolBoxSL2";
# "g" is an arbitrary element in SL(2,K) where "K" is our black box field.
# This function returns a list of unipotent elements whose product gives the element "g".

local a,b,c,d,Snew,di1,zero,m1,am1,dm1,cinv,o1,o2,o3,o4,binv,ainv,mainv,ainvm1;

a:=g[1];
b:=g[2];
c:=g[3];
d:=g[4];
Snew:=LL[1];
di1:=LL[7];
zero:=LL[11];
m1:=AdditiveInverseBBF(LL,di1);

  if (not EquivalentInBBF(Snew,c,zero)) then
    if EquivalentInBBF(Snew,a,di1) and EquivalentInBBF(Snew,d,di1) then
            Info(InfoSL2toBBG,1,"The element is already a unipotent element in natural representation.");
        return [0,2,g];
    elif (not EquivalentInBBF(Snew,a,di1)) and EquivalentInBBF(Snew,d,di1) then
        am1:=AdditionBBF(LL,a,m1);
        cinv:=MultiplicativeInverseBBF(LL,c);
        o1:=[di1,MultiplicationBBF(LL,am1,cinv),zero,di1];
        o2:=[di1,zero,c,di1];
        Info(InfoSL2toBBG,1,"There are 2 unipotents.");
        return [1,1,o1,o2];
    elif (not EquivalentInBBF(Snew,d,di1)) and EquivalentInBBF(Snew,a,di1) then
        dm1:=AdditionBBF(LL,d,m1);
        cinv:=MultiplicativeInverseBBF(LL,c);
        o1:=[di1,zero,c,di1];
        o2:=[di1,MultiplicationBBF(LL,dm1,cinv),zero,di1];
        Info(InfoSL2toBBG,1,"There are 2 unipotents.");
        return [1,2,o1,o2];
    else
        am1:=AdditionBBF(LL,a,m1);
        dm1:=AdditionBBF(LL,d,m1);
        cinv:=MultiplicativeInverseBBF(LL,c);
        o1:=[di1,MultiplicationBBF(LL,am1,cinv),zero,di1];
        o2:=[di1,zero,c,di1];
        o3:=[di1,MultiplicationBBF(LL,dm1,cinv),zero,di1];
        Info(InfoSL2toBBG,1,"There are 3 unipotents.");
        return [1,3,o1,o2,o3];
    fi;
                
  elif (not EquivalentInBBF(Snew,b,zero)) then
    if EquivalentInBBF(Snew,a,di1) and EquivalentInBBF(Snew,d,di1) then
        Info(InfoSL2toBBG,1,"The element is already a unipotent element in natural representation.");
        return [0,1,g];
    elif (not EquivalentInBBF(Snew,a,di1)) and EquivalentInBBF(Snew,d,di1) then
        am1:=AdditionBBF(LL,a,m1);
        binv:=MultiplicativeInverseBBF(LL,b);
        o1:=[di1,b,zero,di1];
        o2:=[di1,zero,MultiplicationBBF(LL,am1,binv),di1];
        Info(InfoSL2toBBG,1,"There are 2 unipotents.");
        return [2,1,o1,o2];
    elif (not EquivalentInBBF(Snew,d,di1)) and EquivalentInBBF(Snew,a,di1) then
        dm1:=AdditionBBF(LL,d,m1);
        binv:=MultiplicativeInverseBBF(LL,b);
        o1:=[di1,zero,MultiplicationBBF(LL,dm1,binv),di1];
        o2:=[di1,b,zero,di1];
        Info(InfoSL2toBBG,1,"There are 2 unipotents.");
        return [2,2,o1,o2];
    else
        am1:=AdditionBBF(LL,a,m1);
        dm1:=AdditionBBF(LL,d,m1);
        binv:=MultiplicativeInverseBBF(LL,b);
        o1:=[di1,zero,MultiplicationBBF(LL,dm1,binv),di1];
        o2:=[di1,b,zero,di1];
        o3:=[di1,zero,MultiplicationBBF(LL,am1,binv),di1];
        Info(InfoSL2toBBG,1,"There are 3 unipotents.");
        return [2,3,o1,o2,o3];
    fi;
  else
    am1:=AdditionBBF(LL,a,m1);
    ainv:=MultiplicativeInverseBBF(LL,a);
    mainv:=AdditiveInverseBBF(LL,ainv);
    ainvm1:=AdditionBBF(LL,ainv,m1);
    o1:=[di1,zero,ainvm1,1];
    o2:=[di1,di1,zero,di1];
    o3:=[di1,zero,am1,di1];
    o4:=[di1,mainv,zero,di1];
    Info(InfoSL2toBBG,1,"There are 4 unipotents.");
    return [3,o1,o2,o3,o4];
  fi;
end;
###################################################################
###################################################################
PGL2toSO3Flat:=function(LL,m)
# "LL" is the output of "ToolBoxSL2";
# "m" a 2x2 projective matrix over our black box field.
# This function returns the image of the matrix "m" in SO3-Flat.

local di1,two,a,b,c,d,ad,bc,mbc,det,delta,a2,ac,2ac,c2,ab,adbc,cd,b2,bd,2bd,d2,a2d,2acd,c2d,abd,adbcd,cdd,b2d,2bdd,d2d;

di1:=LL[7];
two:=AdditionBBF(LL,di1,di1);
a:=m[1];
b:=m[2];
c:=m[3];
d:=m[4];

ad:=MultiplicationBBF(LL,a,d);
bc:=MultiplicationBBF(LL,b,c);
mbc:=AdditiveInverseBBF(LL,bc);
det:=AdditionBBF(LL,ad,mbc);
delta:=MultiplicativeInverseBBF(LL,det);

a2:=MultiplicationBBF(LL,a,a);
ac:=MultiplicationBBF(LL,a,c);
2ac:=MultiplicationBBF(LL,two,ac);
c2:=MultiplicationBBF(LL,c,c);
ab:=MultiplicationBBF(LL,a,b);
adbc:=AdditionBBF(LL,ad,bc);
cd:=MultiplicationBBF(LL,c,d);
b2:=MultiplicationBBF(LL,b,b);
bd:=MultiplicationBBF(LL,b,d);
2bd:=MultiplicationBBF(LL,two,bd);
d2:=MultiplicationBBF(LL,d,d);

a2d:=MultiplicationBBF(LL,a2,delta);
2acd:=MultiplicationBBF(LL,2ac,delta);
c2d:=MultiplicationBBF(LL,c2,delta);
abd:=MultiplicationBBF(LL,ab,delta);
adbcd:=MultiplicationBBF(LL,adbc,delta);
cdd:=MultiplicationBBF(LL,cd,delta);
b2d:=MultiplicationBBF(LL,b2,delta);
2bdd:=MultiplicationBBF(LL,2bd,delta);
d2d:=MultiplicationBBF(LL,d2,delta);

return [a2d,2acd,c2d,abd,adbcd,cdd,b2d,2bdd,d2d];
end;
###################################################################
###################################################################
SL2KtoBBGInvo:=function(LL,svf,gK)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gK" is a 2x2 matrix and an centrally involution in SL(2,K) where K is our black box field.
# This function returns the image of "gK" in our black box group.

local gSO3,g1,g2,hh;


Info(InfoSL2toBBG,1,"Constructing the image in SO3 Flat.");
gSO3:=PGL2toSO3Flat(LL,gK);
Info(InfoSL2toBBG,1,"Constructing the image in SO3 Sharp.");
g1:=MatrixMultiplication3x3BBF(LL,svf[2],gSO3);
g2:=MatrixMultiplication3x3BBF(LL,g1,svf[1]);
Info(InfoSL2toBBG,1,"Constructing the image in the black box group.");
hh:=SO3toBBGInvo(LL,g2);
return hh;
end;
###################################################################
###################################################################
SL2KtoBBGv01:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 1 corresponding to the paper.

local Snew,Eo,id,gu1,gui,o11,o12,p1;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;

gu1:=gU[3];
Info(InfoSL2toBBG,1,"Decomposing the unipotent as a product of two involutions.");
gui:=UnipotentAsInvoProductsV2BBF(LL,gu1);
Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gui[1]);
o12:=SL2KtoBBGInvo(LL,svf,gui[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        return p1;
    else
        return p1*z;
    fi;
end;
###################################################################
###################################################################
SL2KtoBBGv02:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 1 corresponding to the paper.

local Snew,Eo,id,gu1,gui,o11,o12,p1;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;

gu1:=gU[3];
Info(InfoSL2toBBG,1,"Decomposing the unipotent as a product of two involutions.");
gui:=UnipotentAsInvoProductsV1BBF(LL,gu1);

Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gui[1]);
o12:=SL2KtoBBGInvo(LL,svf,gui[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        return p1;
    else
        return p1*z;
    fi;
end;
###################################################################
###################################################################
SL2KtoBBGv11:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 1 corresponding to the paper.

local Snew,Eo,id,gu1,gu2,gu3,gu1i,gu2i,gu3i,o11,o12,p1,q1,o21,o22,p2,q2,o31,o32,p3,q3;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;
gu1:=gU[3];
gu2:=gU[4];
Info(InfoSL2toBBG,1,"Decomposing each unipotent as a product of two involutions.");
gu1i:=UnipotentAsInvoProductsV1BBF(LL,gu1);
gu2i:=UnipotentAsInvoProductsV2BBF(LL,gu2);

Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gu1i[1]);
o12:=SL2KtoBBGInvo(LL,svf,gu1i[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        q1:=p1;
    else
        q1:=p1*z;
    fi;

Info(InfoSL2toBBG,1,"Involution #3 and #4:");
o21:=SL2KtoBBGInvo(LL,svf,gu2i[1]);
o22:=SL2KtoBBGInvo(LL,svf,gu2i[2]);
p2:=o21[1]*o22[1];
    if p2^Eo = id then
        q2:=p2;
    else
        q2:=p2*z;
    fi;
return q1*q2;
end;
###################################################################
###################################################################
SL2KtoBBGv12:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 1 corresponding to the paper.

local Snew,Eo,id,gu1,gu2,gu3,gu1i,gu2i,gu3i,o11,o12,p1,q1,o21,o22,p2,q2,o31,o32,p3,q3;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;
gu1:=gU[3];
gu2:=gU[4];
Info(InfoSL2toBBG,1,"Decomposing each unipotent as a product of two involutions.");
gu1i:=UnipotentAsInvoProductsV2BBF(LL,gu1);
gu2i:=UnipotentAsInvoProductsV1BBF(LL,gu2);

Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gu1i[1]);
o12:=SL2KtoBBGInvo(LL,svf,gu1i[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        q1:=p1;
    else
        q1:=p1*z;
    fi;

Info(InfoSL2toBBG,1,"Involution #3 and #4:");
o21:=SL2KtoBBGInvo(LL,svf,gu2i[1]);
o22:=SL2KtoBBGInvo(LL,svf,gu2i[2]);
p2:=o21[1]*o22[1];
    if p2^Eo = id then
        q2:=p2;
    else
        q2:=p2*z;
    fi;

return q1*q2;
end;
###################################################################
###################################################################
SL2KtoBBGv13:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 1 corresponding to the paper.

local Snew,Eo,id,gu1,gu2,gu3,gu1i,gu2i,gu3i,o11,o12,p1,q1,o21,o22,p2,q2,o31,o32,p3,q3;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;
gu1:=gU[3];
gu2:=gU[4];
gu3:=gU[5];
Info(InfoSL2toBBG,1,"Decomposing each unipotent as a product of two involutions.");
gu1i:=UnipotentAsInvoProductsV1BBF(LL,gu1);
gu2i:=UnipotentAsInvoProductsV2BBF(LL,gu2);
gu3i:=UnipotentAsInvoProductsV1BBF(LL,gu3);

Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gu1i[1]);
o12:=SL2KtoBBGInvo(LL,svf,gu1i[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        q1:=p1;
    else
        q1:=p1*z;
    fi;

Info(InfoSL2toBBG,1,"Involution #3 and #4:");
o21:=SL2KtoBBGInvo(LL,svf,gu2i[1]);
o22:=SL2KtoBBGInvo(LL,svf,gu2i[2]);
p2:=o21[1]*o22[1];
    if p2^Eo = id then
        q2:=p2;
    else
        q2:=p2*z;
    fi;

Info(InfoSL2toBBG,1,"Involution #5 and #6:");
o31:=SL2KtoBBGInvo(LL,svf,gu3i[1]);
o32:=SL2KtoBBGInvo(LL,svf,gu3i[2]);
p3:=o31[1]*o32[1];
    if p3^Eo = id then
        q3:=p3;
    else
        q3:=p3*z;
    fi;
return q1*q2*q3;
end;
###################################################################
###################################################################
SL2KtoBBGv23:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 2 corresponding to the paper.

local Snew,Eo,id,gu1,gu2,gu3,gu1i,gu2i,gu3i,o11,o12,p1,q1,o21,o22,p2,q2,o31,o32,p3,q3;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;
gu1:=gU[3];
gu2:=gU[4];
gu3:=gU[5];
Info(InfoSL2toBBG,1,"Decomposing each unipotent as a product of two involutions.");
gu1i:=UnipotentAsInvoProductsV2BBF(LL,gu1);
gu2i:=UnipotentAsInvoProductsV1BBF(LL,gu2);
gu3i:=UnipotentAsInvoProductsV2BBF(LL,gu3);

Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gu1i[1]);
o12:=SL2KtoBBGInvo(LL,svf,gu1i[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        q1:=p1;
    else
        q1:=p1*z;
    fi;

Info(InfoSL2toBBG,1,"Involution #3 and #4:");
o21:=SL2KtoBBGInvo(LL,svf,gu2i[1]);
o22:=SL2KtoBBGInvo(LL,svf,gu2i[2]);
p2:=o21[1]*o22[1];
    if p2^Eo = id then
        q2:=p2;
    else
        q2:=p2*z;
    fi;
    
Info(InfoSL2toBBG,1,"Involution #5 and #6:");
o31:=SL2KtoBBGInvo(LL,svf,gu3i[1]);
o32:=SL2KtoBBGInvo(LL,svf,gu3i[2]);
p3:=o31[1]*o32[1];
    if p3^Eo = id then
        q3:=p3;
    else
        q3:=p3*z;
    fi;
return q1*q2*q3;
end;
###################################################################
###################################################################
SL2KtoBBGv3:=function(LL,svf,gU,z)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "gU" is a list of unipotent elements from SL2 over a prime field of type version 3 corresponding to the paper.

local Snew,Eo,id,gu1,gu2,gu3,gu4,gu1i,gu2i,gu3i,gu4i,o11,o12,p1,q1,o21,o22,p2,q2,o31,o32,p3,q3,o41,o42,p4,q4;

Snew:=LL[1];
Eo:=LL[13];
id:=z^2;
gu1:=gU[2];
gu2:=gU[3];
gu3:=gU[4];
gu4:=gU[5];
Info(InfoSL2toBBG,1,"Decomposing each unipotent as a product of two involutions.");
gu1i:=UnipotentAsInvoProductsV2BBF(LL,gu1);
gu2i:=UnipotentAsInvoProductsV1BBF(LL,gu2);
gu3i:=UnipotentAsInvoProductsV2BBF(LL,gu3);
gu4i:=UnipotentAsInvoProductsV1BBF(LL,gu4);

Info(InfoSL2toBBG,1,"Involution #1 and #2:");
o11:=SL2KtoBBGInvo(LL,svf,gu1i[1]);
o12:=SL2KtoBBGInvo(LL,svf,gu1i[2]);
p1:=o11[1]*o12[1];
    if p1^Eo = id then
        q1:=p1;
    else
        q1:=p1*z;
    fi;
Info(InfoSL2toBBG,1,"Involution #3 and #4:");
o21:=SL2KtoBBGInvo(LL,svf,gu2i[1]);
o22:=SL2KtoBBGInvo(LL,svf,gu2i[2]);
p2:=o21[1]*o22[1];
    if p2^Eo = id then
        q2:=p2;
    else
        q2:=p2*z;
    fi;
Info(InfoSL2toBBG,1,"Involution #5 and #6:");
o31:=SL2KtoBBGInvo(LL,svf,gu3i[1]);
o32:=SL2KtoBBGInvo(LL,svf,gu3i[2]);
p3:=o31[1]*o32[1];
    if p3^Eo = id then
        q3:=p3;
    else
        q3:=p3*z;
    fi;
Info(InfoSL2toBBG,1,"Involution #7 and #8:");
o41:=SL2KtoBBGInvo(LL,svf,gu4i[1]);
o42:=SL2KtoBBGInvo(LL,svf,gu4i[2]);
p4:=o41[1]*o42[1];
    if p4^Eo = id then
        q4:=p4;
    else
        q4:=p4*z;
    fi;
return q1*q2*q3*q4;
end;
###################################################################
###################################################################
FieldElementBBF:=function(LL,a)
# "LL" is the output of "ToolBoxSL2".
# "a" is a non-negative integer.
# This function returns the black box field element representing the integer "a".

local di1,zero,l,M,0in,x,k,i,y,f,ll,two;

di1:=LL[7];
zero:=LL[11];

if a=0 then
  return zero;
elif a=1 then
  return di1;
else
  l:=BinaryRep(a);
  M:=Maximum(l);
    if 0 in l then
      0in:=true;
    else
      0in:=false;
    fi;
  ll:=[];
  two:=AdditionBBF(LL,di1,di1);
  x:=di1;
  k:=1;
    for i in [1..M] do
      if i in l then
        x:=MultiplicationBBF(LL,x,two);
        ll[k]:=x;
        k:=k+1;
      else
        x:=MultiplicationBBF(LL,x,two);
      fi;
    od;
  y:=ll[1];
    for f in [2..(k-1)] do
      y:=AdditionBBF(LL,y,ll[f]);
    od;
fi;
    if 0in=true then
      return AdditionBBF(LL,y,di1);
    else
      return y;
    fi;
end;
###################################################################
###################################################################
SL2ptoSL2:=function(LL,g)
# "LL" is the output of "ToolBoxSL2".
# "g" is an element from SL(2,p) where "p" is a prime number. We assume that "g" is given as an element produced from GAP.

local g1,g2,g3,g4;

g1:=FieldElementBBF(LL,Int(g[1][1]));
g2:=FieldElementBBF(LL,Int(g[1][2]));
g3:=FieldElementBBF(LL,Int(g[2][1]));
g4:=FieldElementBBF(LL,Int(g[2][2]));

return [g1,g2,g3,g4];
end;
###################################################################
###################################################################
SL2ptoBBG:=function(LL,svf,g)
# "LL" is the output of "ToolBoxSL2",
# "svf" is the output of "SharpVsFlat",
# "g" is a random element from a group SL2 over a prime field produced in GAP format.
# This function takes 2x2 matrix as an input and constructs an image in the black box group.

local Gens,gK,gU,z;

Gens:=LL[1][1];
z:=(Invo(Gens,LL[13]))^2;
Info(InfoSL2toBBG,1,"Computing the image of the group element in SL(2,K).");
gK:=SL2ptoSL2(LL,g);
Info(InfoSL2toBBG,1,"Constructing the unipotents in its decomposition.");
gU:=ElementAsUnipotentProductsBBF(LL,gK);
    if gU[1]=0 and gU[2]=1 then
        return SL2KtoBBGv01(LL,svf,gU,z);
    elif gU[1]=0 and gU[2]=2 then
        return SL2KtoBBGv02(LL,svf,gU,z);
    elif gU[1]=1 and gU[2]=1 then
        return SL2KtoBBGv11(LL,svf,gU,z);
    elif gU[1]=1 and gU[2]=2 then
        return SL2KtoBBGv12(LL,svf,gU,z);
     elif gU[1]=1 and gU[2]=3 then
        return SL2KtoBBGv13(LL,svf,gU,z);
    elif gU[1]=2 and gU[2]=1 then
        return SL2KtoBBGv11(LL,svf,gU,z);
    elif gU[1]=2 and gU[2]=2 then
        return SL2KtoBBGv12(LL,svf,gU,z);
     elif gU[1]=2 and gU[2]=3 then
        return SL2KtoBBGv23(LL,svf,gU,z);
    elif gU[1]=3 then
        return SL2KtoBBGv3(LL,svf,gU,z);
    fi;
end;
